# 객체지향 쿼리 언어

## 객체지향 쿼리 언어란?
* 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리. 
* sql을 추상화해서 특정 데이터베이스 sql에 의존하지 않음. 

### JPQL 소개 
* 엔티티 객체를 조회하는 객체지향 쿼리 
* JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않음. 
* JPQL은 SQL 보다 간결.

```java
@Entity(name="Member")
public class Member {
    @Colum(name="name")
    private String username;
}

// JPQL 사용. 
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```

```
// 실행한 JPQL
select m
  from Member as m
 where m.username = 'kim'
}

// 실행된 SQL
select member.id as id
      ,member.age as age
      ,member.team_id as team
      ,member.name as name
  from Member member
 where member.name = 'kim'
```

### Criteria 쿼리 
* Criteria 는 JPQL을 생성하는 빌더 클래스
* 문자가 아닌 프로그래밍 코드로 JPQL을 작성할 수 있음 ex) query.select(m).where(...)
* 문자로 작성한 JPQL 보다 코드로 작성한 Criteria의 장점
    * 컴파일 시점에 오류 발견
    * IDE를 사용하면 코드 자동완성 지원
    * 동적쿼리 작성하기 편리 
* 복잡하고 장황하여 사용하기 불편하고, criteria로 작성한 코드도 한눈에 들어오지않는 다는 단점이 있음. 
```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
```

### QueryDSL 소개
* Criteria 처럼 JPQL 빌더 역할
* 코드 기반이면서 단순하고 사용하기 쉬움. 
* 작성한 코드도 JPQL 과 비슷해서 한눈에 들어옴. 

```java
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

Lisg<Member> members = query.from(member)
                            .where(member.username.eq("kim"))
                            .list(member);
```

### 네이티브 SQL 소개
* sql을 직접 사용할 수 있는 기능을 지원하는데 이것을 네티이브 sql 이라고 함. 
* JPQL에서 표준화 되어있지 않은 기능, 특정 데이터베이스에 의존해야하는 기능을 사용할 때 ex. oracle의 connection by나 특정 데이터베이스에서만 동작하는 sql
```
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQeury(sql, Member.class).getResultList();
```

##JPQL

### 기본문법
* JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있음. 
* 엔티티를 저장할 때는 EntityManager.persist()를 사용하면 되므로 INSERT 문은 없음.

#### JPQL 문법 
```
select_문 :: =
    select_절
      from_절
     [where_절]
     [groupby_절]
     [having_절]
     [orderby_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

#### SELECT문
    * SELECT m FROM Member AS m where m.username = 'Hello'
    * 엔티티와 속성은 대소문자 구분(ex. Member, username) 
    * SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않음.
    * JPQL에서 사용한 Member 는 클래스명이 아니라 엔티티명. 엔티티명은 @Entity(name="XXXX")로 지정할 수 있음. 엔티티명을 지정하지 않으면 기본값으로 클래스명 사용. 
    * 별칭은 필수 Member As m
    
#### TypeQuery, Query
* 작성한 JPQL을 실행하려면 쿼리객체(TypeQuery, Query)를 만들어야함.
* TypeQuery : 반환할 타입을 명확하게 지정할 수 있을 때 사용 
```java
    TypeQuery<Member> query = em.createQuery("SELECT m FRom Member m", Member.class);
```
* Query : 반환 타입을 명확하게 지정할 수 없을 때 사용 
```java
   Query query = em.createQuery("SELECT m.username, m age from Member m");
```














