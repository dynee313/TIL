# 객체지향 쿼리 언어

## 객체지향 쿼리 언어란?
* 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리. 
* sql을 추상화해서 특정 데이터베이스 sql에 의존하지 않음. 

### JPQL 소개 
* 엔티티 객체를 조회하는 객체지향 쿼리 
* JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않음. 
* JPQL은 SQL 보다 간결.

```java
@Entity(name="Member")
public class Member {
    @Colum(name="name")
    private String username;
}

// JPQL 사용. 
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```

```
// 실행한 JPQL
select m
  from Member as m
 where m.username = 'kim'
}

// 실행된 SQL
select member.id as id
      ,member.age as age
      ,member.team_id as team
      ,member.name as name
  from Member member
 where member.name = 'kim'
```

### Criteria 쿼리 
* Criteria 는 JPQL을 생성하는 빌더 클래스
* 문자가 아닌 프로그래밍 코드로 JPQL을 작성할 수 있음 ex) query.select(m).where(...)
* 문자로 작성한 JPQL 보다 코드로 작성한 Criteria의 장점
    * 컴파일 시점에 오류 발견
    * IDE를 사용하면 코드 자동완성 지원
    * 동적쿼리 작성하기 편리 
* 복잡하고 장황하여 사용하기 불편하고, criteria로 작성한 코드도 한눈에 들어오지않는 다는 단점이 있음. 
```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
```

### QueryDSL 소개
* Criteria 처럼 JPQL 빌더 역할
* 코드 기반이면서 단순하고 사용하기 쉬움. 
* 작성한 코드도 JPQL 과 비슷해서 한눈에 들어옴. 

```java
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

Lisg<Member> members = query.from(member)
                            .where(member.username.eq("kim"))
                            .list(member);
```

### 네이티브 SQL 소개
* sql을 직접 사용할 수 있는 기능을 지원하는데 이것을 네티이브 sql 이라고 함. 
* JPQL에서 표준화 되어있지 않은 기능, 특정 데이터베이스에 의존해야하는 기능을 사용할 때 ex. oracle의 connection by나 특정 데이터베이스에서만 동작하는 sql
```
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQeury(sql, Member.class).getResultList();
```

##JPQL

### 기본문법
* JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있음. 
* 엔티티를 저장할 때는 EntityManager.persist()를 사용하면 되므로 INSERT 문은 없음.

#### JPQL 문법 
```
select_문 :: =
    select_절
      from_절
     [where_절]
     [groupby_절]
     [having_절]
     [orderby_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

##### SELECT문
    * SELECT m FROM Member AS m where m.username = 'Hello'
    * 엔티티와 속성은 대소문자 구분(ex. Member, username) 
    * SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않음.
    * JPQL에서 사용한 Member 는 클래스명이 아니라 엔티티명. 엔티티명은 @Entity(name="XXXX")로 지정할 수 있음. 엔티티명을 지정하지 않으면 기본값으로 클래스명 사용. 
    * 별칭은 필수 Member As m
    
##### TypeQuery, Query
* 작성한 JPQL을 실행하려면 쿼리객체(TypeQuery, Query)를 만들어야함.
* TypeQuery : 반환할 타입을 명확하게 지정할 수 있을 때 사용 
```java
    TypeQuery<Member> query = em.createQuery("SELECT m FRom Member m", Member.class);
    List<Member> resultList = query.getResultList();
```
* Query : 반환 타입을 명확하게 지정할 수 없을 때 사용 
```java
   Query query = em.createQuery("SELECT m.username, m age from Member m");
   List resultList = query.getResultList();
```

* query.getResultList() : 결과를 예제로 반환 결과가 없으면 빈 컬렉션 반환
* query.getSingleResult() : 결과가 정확히 하나일때 사용.
    * 결과가 없으면 javax.persistence.NoResultException 예외 발생
    * 결과가 1개보다 많으면 javadx.persistence.NonUniqueResultException 예외 발생
    
#### 파라미터 바인딩
* 이름 기준 파라미터 : JDBC는 위치 기준 파라미터 바인딩만 지원하지만, JPQL은 이름 기준 파라미터 바인딩도 지원함. 
    * 파라미터를 이름으로 구분하며 : 를 사용. 
```java
String usernameParam = "User1";
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m where m.username = :username");
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();

// 메소드 체이닝 방식으로도 가능
List<Member> resultList = em.createQuery("SELECT m FROM Member m where m.username = :username")
                            .setParameter("username", usernameParam)
                            .getResultList();
```

* 위치기준 파라미터 : ? 다음에 위치 값을 주면 됨
```java
List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
                         .setParameter(1, usernameParam)
                         .getResultList();
```

* 파라미터 바인딩 방식을 사용하지않고 문자를 더해 만들어 넣으면 악의적인 사용자에 의해 SQL인젝션 공격을 당할 수 있음
* 파라미터 방식을 사용하면 파라미터의 값이 달라도 같은 쿼리로 인식해서 JPA는 JPQL을 SQL로 파싱한 결과를 재사용할 수 있음. 

#### 프로젝션 
* SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라고함. 
* 프로젝션 대상은 엔티티, 임베디드타입, 스칼라 타입(문자, 숫자 등 기본 데이터 타입)이 있음. 

##### 엔티티 프로젝션
* 엔티티프로젝션을 사용하면 조회한 엔티티는 영속성 컨텍스트에서 관리 
```
SELECT m FROM Member m 
SELECT m.team FROM Member m 
```

##### 임베디드 타입 프로젝션
* 임베디드 타입은 조회의 시작점이 될 수 없음. 
```
// 잘못된 쿼리, 임베디드 타입인 Address가 시작점이 아니기떄문에 잘못된 쿼리 
String query = "SELECT a FROM Address a";    

// Order 엔티티가 시작점 엔티티를 통해서 임베디드 타입 조회가능 
* 임베디드 타입은 엔티티 타입이 아닌 값 타입이므로 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않음.
String query = "SELECT o.address FROM Order o";  
List<Address> addrreses = em.createQuery(query, Address.class).getResultList()능;

//실행된 SQL
SELECT order.city, order.street, order.zipcode from Orders order
```

##### 스칼라 타입 프로젝션
* 숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라고 함.
```java
    List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class).getResultList();
```

##### 여러값 조회 : Query 사용.
* 프로젝션에 여러 값을 선택하면 TypeQuery 대신에 Query를 사용해야함.
```java
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```

##### NEW 명령어 
* new 명령어를 사용하면 반환받을 클래스 지정 가능.
* 객체 변환 작업을 줄일 수 있음. 

* NEW 명령어 사용 전
```java
List<Object[]> resultList = em.createQuery("SELECT m.username. m.age FROM Member m").getResultList(); 
List<UserDTO> userDTOs = new ArrayList<UserDTO>();
for (Object[] row : resultList) {
    UserDTO userDTO = new UserDTO((String)row[0], (Integer)row[1]);
    usetDTOs.add(userDTO);
}
```
* NEW 명령어 사용 후 
    * 패키지명을 포함한 전체 클래스 명을 입력해야한다.
    * 순서와 타입이 일치하는 생성자가 필요.
```java
TypeQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username. m.age) FROM Member m", UserDTO.class); 
List<UserDTO> resultList = query.getResultList();
```

#### 페이징 API
* 데이터베이스마다 페이징을 처리하는 sql 문법이 다르지만, JPQL은 데이터베이스에 상관없이 API를 통해 페이징을 처리할 수 있음. 
* setFirstResult(int startPosition) : 조회 시작 위치 (0부터 시작)
* setMaxResults(int maxResult) : 조회할 데이터 수
```java
TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class);
query.setFirstResult(10);   // 11번째부터 시작해서
query.setMaxResult(20);     // 총 20건의 데이터 조회 
query.getResultList();
```

#### 집합과 정렬

##### 집합 
```
select 
    COUNT(m),       // 회원수  
    SUM(m.age),     // 나이 합
    AVG(m.age),     // 평균 나이
    MAX(m.age),     // 최대 나이 
    MIN(m.age)      // 최소 나이 
  from Member m
```

##### GROUP BY, HAVING
* groupby_절 ::= GROUP BY {단일값 경로| 별칭} +
* having_절 ::= HAVING 조건식 

```
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
  from Member m LEFT JOIN m.team t
 group by t.name
```

```
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
  from Member m LEFT JOIN m.team t
 group by t.name
 having AVG(m.age) >= 10
```

##### ORDER BY
* orderby_절 ::= ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]} +
```
select t.name, COUNT(m.age) as cnt
  from Member m LEFT JOIN m.team t
 GROUP BY t.name
 ORDER BY cnt
```

#### JPQL 조인

##### 내부 조인
* INNER JOIN을 사용하며, INNER는 생략할 수 있음 
* 연관 필드 : 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드
    * 하단 코드의 m.team을 연관필드
* JPQL 조인을 SQL 조인처럼 사용하면 문법 오류가 발생. FROM Member m JOIN Team t -> 잘못된 JPQL 조인
```java
String teamName = "팀A";
String query = "SELECT m "
               + "FROM Member m" 
               + "INNER JOIN m.team t" // 회원이 가지고 있는 연관 필드로 팀과 조인 
               + "WHERE t.name = :teamName";

List<Member> members = em.createQuery(query, Member.class).setParameter("teamName", teamName).getResultList();
```

* 생성된 내부 조인 SQL
```
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
 FROM
    MEMBER M INNER JOIN TEAM T ON M.TEAM_ID = T.ID
WHERE
    T.NAME = ?
```

* 조인한 두 개의 엔티티를 조회하려면 다음과 같이 JPQL을 작성하면 됨.
```java
SELECT m, t FROM Member m JOIN m.team
List<Object[]> result = em.createQuery(query).getResultList();

for (Object[] row : result) {
    Member member = (Member) row[0];
    Team team = (Team) row[1];
}
 
```






