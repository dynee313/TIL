# JPA 데이터 타입
 * 엔티티타입 
    * @Entity로 정의하는 객체
    * 식별자를 통해 지속해서 추적할 수 있음
 * 값 타입 
    * int, Integer, String 처럼 단순 값으로 사용하는 자바 기본 타입이나 객체
    * 식별자가 없고 숫자나 문자같은 속성만 있으므로 추적 불가
    * 기본값타입, 임베디드탙입, 컬렉션 값 타입으로 나눌 수 있음
    
    
 
 ## 기본 값 타입
 
 ```java
@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;
    private String name;
    private int age;
}
```
* String, int가 값타입이며 Member 엔티티의 생명주기에 의존
* 값 타입은 공유하면 변경되기때문에 공유하면 안됨.
 
## 임베디드 타입(복합 값 타입)
* 새로운 값 타입을 직접 정의해서 사용 
    * 재사용 가능
    * 응집도 높음 (응집도가 높으면 연관성이 높음)
* 직접 정의한 임베디드 타입도 int, String 처럼 값 타입임.
* 임베디드 타입은 기본 생성자가 필수.
* 엔티티와 임베디드 타입의 관계를 UML로 표현하면 컴포지션 관계가 됨
    * 컴포지션 : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 메서드를 호출하는 기법
* Embeddable : 값 타입을 정의하는 곳에 표시
* Embedded : 값 타입을 사용하는 곳에 표시.

 ```java
@Embeddable
public class Period {
    @Temporal(TemporalType.DATE) Date startDate;
    @Temporal(TemporalType.DATE) Date endDate;
    
    public boolean isWork(Date date) {
        // 값 타입을 위한 메서드 정의
    }
}
```

 ```java
@Embeddable
public class Address {
    @Column(name="city")
    private String city;
    private String street;
    private String zipcode;
}
```

 ```java
@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embedded Period workPeriod;        // 근무기간
    @Embedded Address homeAddress;      // 집 주소
}
```

### 임베디드 타입과 연관관계 
* 임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있음. 
```java
@Entity
public class Member {

    @Embedded Address address;
    @Embedded PhoneNumber phonenumber;
}

@Embeddable
public class Address {

    String street;
    String city;
    String state;
    @Embedded Zipcode zipcode;  // 임베디드 타입 포함
}

@Embeddable
public class Zipcode {

    String zip;
    String plusFour;
}

@Embeddable
public class phoeNumber {
    String areaCode;
    String localNumber;
    @ManyToOne PhoneServiceProvider provider; // 엔티티 참조
}

@Entity
public class PhoneServiceProvider {
    @Id String name;
}
```


### @AttributeOverride
* 임베디드 타입에 정의한 매핑정보를 재정의 
 ```java
@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embedded Address homeAddress;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name="city", column=@Column(name="COMPANY_CITY")),
        @AttributeOverride(name="street", column=@Column(name="COMPANY_STREET")),
        @AttributeOverride(name="zipcode", column=@Column(name="COMPANY_ZIPCODE")),   
    })
    Address companyAddress;
}
```
```
CREATE TABLE MEMBER {
    COMPANY_CITY varchar(255),  
    COMPANY_STREET varchar(255),
    COMPANY_ZIPCODE varchar(255),  
    city varchar(255),
    street varchar(255),
    zipcode varchar(255),
    ...
}
```

### 임베디드 타입과 null
* 임베디드 타입이 null 이면 매핑한 컬럼 값은 모두 null이 된다. 
    * member.setAddress(null) -> city, street, zipcode 모두 null
    
    
## 값 타입과 불변 객체

### 값 타입 공유 참조 
* 임베디드 같은 값 타입을 여러 엔티티에서 공유하면 위험
```
    member1.setHomeAddress(new Address("OldCity"));
    Address address = member1.getHomeAddress();
    address.setCity("newCity");
    member2.setHomeAddress(address);
```
* 회원2의 주소만 NewCity로 변경되는게 아니라 회원1의 주소도 NewCity로 변경됨.
* 이런 부작용을 막으려면 아래와 같이 값을 복사해서 사용 
```
    member1.setHomeAddress(new Address("OldCity"));
    Address address = member1.getHomeAddress();

    // address 값을 복사해서 새로운 newAddress 생성.
    Address newAddress = address.clone();

    newAddress.setCity("newCity");
    member2.setHomeAddress(newAddress);
```
* 객체의 공유 참조는 피할 수 없으니, 객체의 값을 수정하지 못하게 setCity() 같은 수정자 메서드를 모두 제거하여 부작용 발생을 막을 수 있음.

## 값 타입 컬렉션
* 값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 @ElementCollection, @CollectionTable 어노테이션을 사용.

```java
@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;
    
    @Embedded Address homeAddress;
    
    @ElementCollection
    @CollectionTable(name="FABORITE_FOODS", joinColumns=@JoinColumn(name="MEMBER_ID"))
    @Column(name="FOOD_NAME")
    private Set<String> favoriteFoods = new HashSet<String>();
    
    @ElementCollection
    @CollectionTable(name="ADDRESS", joinColumns = @JoinColumn(name="MEMBER_ID"))
    private List<Address> addressHistory = new ArrayList<Address>();

}
```









